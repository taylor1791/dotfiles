[[ $- != *i* ]] && return

LOCAL_BASHRC="$HOME/.bashrc.local"

# A minimilist prompt
export PS1="\u@\h:\w\\$ "
export HISTSIZE="10000"
export VISUAL=vim
export EDITOR=$VISUAL

# Enhance PATH
export PATH="$HOME/.bin:$HOME/bin:$PATH"

# Better defaults
alias ls="ls -G"
alias la="ls -AlF"
alias ll="ls -AlF"

# Correct tpye-os
alias l="ls"
alias sl="ls"
alias g="git"

alias t="tmux attach -t"
alias jpost="curl -X POST -H 'Content-Type: application/json' -d"
alias jput="curl -X PUT -H 'Content-Type: application/json' -d"

# Load direnv
eval "$(direnv hook bash)"

# Load "z"
eval "$(zoxide init bash)"

[[ -f "$LOCAL_BASHRC" ]] && source "$LOCAL_BASHRC"

function warn() {
  if [[ -n "$TERM" && "$TERM" != "dumb" && "$TERM" != "unknown" && -n "$(which tput)" ]]; then
    tput bold
    tput setaf 1
    echo "$@"
    tput sgr0
  else
    echo "$@"
  fi
}

# Dotfiles framework warnings
if [[ $- == *i* ]]; then # In non-interactive shells $PS1 is not set
  # Download the updates
  pushd $HOME/.dotfiles > /dev/null
  # { git fetch & disown; } 2>/dev/null

  if [[ "$(git status -s)" != "" ]]; then
    warn "There are uncommitted changed to dotfiles"
  fi

  if [[ "$(git name-rev --name-only HEAD)" != "master" ]]; then
    warn "Dotfiles are in development mode"
  elif [[ "$(git rev-parse origin/master)" != "$(git rev-parse master)" ]]; then
    warn "Updates available for dots. Run pushd ~/.dotfiles; git pull; popd"
  fi
  popd > /dev/null
fi

# Changes to the directory with the specified name, unless passed an integer.
# Integers navigate to the nth-parent defaulting to 1.
function up() {
  dir=""
  if [ -z "$1" ]; then
    dir=..
  elif [[ $1 =~ ^[0-9]+$ ]]; then
    x=0
    while [ $x -lt ${1:-1} ]; do
        dir=${dir}../
        x=$(($x+1))
    done
  else
    dir=${PWD%/$1/*}/$1
  fi
  cd "$dir";
}

# Tests for true color support
function truecolor() {
  awk 'BEGIN{
    s="/\\/\\/\\/\\/\\"; s=s s s s s s s s;
    for (colnum = 0; colnum<77; colnum++) {
        r = 255-(colnum*255/76);
        g = (colnum*510/76);
        b = (colnum*255/76);
        if (g>255) g = 510-g;
        printf "\033[48;2;%d;%d;%dm", r,g,b;
        printf "\033[38;2;%d;%d;%dm", 255-r,255-g,255-b;
        printf "%s\033[0m", substr(s,colnum+1,1);
    }
    printf "\n";
  }'
}

function lines() {
  local start="${1}"
  local total="${2}"
  local file="${3}"
  local end="$((${start} + ${total} - 1))"
  local quit="$((${end} + 1))"

  sed -n "${start},${end}p;${quit}q" "${file}"
}
